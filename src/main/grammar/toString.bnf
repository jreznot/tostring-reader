{
  parserClass="org.strangeway.tsr.parser.TslParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Tsl"
  psiImplClassSuffix="Impl"
  psiPackage="org.strangeway.tsr.psi"
  psiImplPackage="org.strangeway.tsr.psi.impl"

  elementTypeHolderClass="org.strangeway.tsr.psi.TslTokenTypes"
  elementTypeClass="org.strangeway.tsr.psi.TslElementType"
  tokenTypeClass="org.strangeway.tsr.psi.TslTokenType"
  psiImplUtilClass="org.strangeway.tsr.psi.TslPsiUtils"
  tokens = [
    LBRACKET='['
    RBRACKET=']'
    LPARENTH='('
    RPARENTH=')'
    LBRACE='{'
    RBRACE='}'
    COMMA=','
    COLON=':'
    TRUE='true'
    FALSE='false'
    NULL='null'
    ASSIGN='='
  ]
}

root ::= value

value ::= stringLiteral | numberLiteral | booleanLiteral | nullLiteral | objectRef | objectBrace | objectParenth | objectId | list | map

objectRef ::= IDENTIFIER STRUDEL_HEX {
    pin = 2
    extends = value
}

objectId ::= IDENTIFIER {
    extends = value
}

propertiesList ::= keyValue*

keyValue ::= propertyKey ASSIGN value (COMMA|&(RPARENTH|RBRACE)) {
    pin = 2
    recoverWhile = notRBraceParenthOrNextValue
}

fake object ::= objectName propertiesList? {
    extends = value
}

objectParenth ::= objectName LPARENTH propertiesList RPARENTH {
    pin = 2
    extends = object
}

objectBrace ::= objectName LBRACE propertiesList RBRACE {
    pin = 2
    extends = object
}

objectName ::= IDENTIFIER

propertyKey ::= IDENTIFIER

list ::= LBRACKET listItem* RBRACKET {
    pin = 1
    extends = value
}

private listItem ::= value (COMMA|&RBRACKET) {
    pin = 1
    recoverWhile = notRBracketOrNextValue
}

map ::= LBRACE mapItem* RBRACE {
    pin = 1
}

mapItem ::= mapKey ASSIGN value (COMMA|&RBRACE) {
    pin = 2
    recoverWhile = notRBraceOrNextValue
}

mapKey ::= nullLiteral | booleanLiteral | objectRef | objectId | numberLiteral

booleanLiteral ::= TRUE | FALSE {
    extends = value
}

numberLiteral ::= DOUBLE_NUMBER | INTEGER_NUMBER {
    extends = value
}

stringLiteral ::= DOUBLE_QUOTED_STRING | SINGLE_QUOTED_STRING {
    extends = value
}

nullLiteral ::= NULL {
    extends = value
}

private notRBracketOrNextValue ::= !(RBRACKET|value)
private notRBraceOrNextValue ::= !(RBRACE|value)
private notRBraceParenthOrNextValue ::= !(RPARENTH|RBRACE|value)
